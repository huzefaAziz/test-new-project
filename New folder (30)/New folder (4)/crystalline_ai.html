<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystalline Intelligence System - Non-Neural AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 100%);
            color: #00ff88;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #00ff88;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px #00ff88; }
            to { text-shadow: 0 0 40px #00ff88, 0 0 60px #00ff88; }
        }

        .subtitle {
            text-align: center;
            color: #66ffaa;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .info-box {
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .info-box h2 {
            color: #00ffff;
            margin-bottom: 10px;
        }

        .info-box p {
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .panel {
            background: rgba(10, 10, 30, 0.8);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
        }

        .panel h3 {
            color: #00ffff;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        #crystalCanvas {
            width: 100%;
            height: 400px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff88;
            border-radius: 5px;
            cursor: crosshair;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #66ffaa;
        }

        input[type="text"], textarea, select {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: #00ff88;
            font-family: 'Courier New', monospace;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        button {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #0a0a1a;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1em;
            transition: all 0.3s;
            margin-right: 10px;
            margin-top: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.5);
        }

        .crystal-info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .crystal-info::-webkit-scrollbar {
            width: 8px;
        }

        .crystal-info::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        .crystal-info::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 4px;
        }

        .crystal-node {
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid #00ff88;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 3px;
        }

        .crystal-node strong {
            color: #00ffff;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: rgba(0, 255, 136, 0.1);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-box .value {
            font-size: 1.5em;
            color: #00ffff;
            font-weight: bold;
        }

        .stat-box .label {
            font-size: 0.9em;
            color: #66ffaa;
        }

        .output-box {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff88;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
        }

        .query-result {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
        }

        .query-result:last-child {
            border-bottom: none;
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚¨° CRYSTALLINE INTELLIGENCE SYSTEM ‚¨°</h1>
        <p class="subtitle">A Novel Non-Neural AI Architecture Based on Pattern Crystallization</p>

        <div class="info-box">
            <h2>üî¨ How It Works</h2>
            <p><strong>Unlike neural networks</strong>, this system uses <strong>Crystalline Pattern Growth</strong> - knowledge forms like crystal structures where:</p>
            <p>‚ú¶ <strong>Seed Nodes</strong> represent core concepts (words, patterns, rules)</p>
            <p>‚ú¶ <strong>Lattice Connections</strong> form based on co-occurrence, semantic similarity, and rule-based affinities</p>
            <p>‚ú¶ <strong>Resonance Propagation</strong> spreads activation through the crystal structure to find answers</p>
            <p>‚ú¶ <strong>Facet Formation</strong> creates decision boundaries without gradient descent or backpropagation</p>
            <p><strong>No weights, no neurons, no training epochs</strong> - just pure symbolic pattern crystallization!</p>
        </div>

        <div class="main-grid">
            <div class="panel">
                <h3>üìä Crystal Knowledge Lattice</h3>
                <canvas id="crystalCanvas"></canvas>
                <div class="stats">
                    <div class="stat-box">
                        <div class="value" id="nodeCount">0</div>
                        <div class="label">Crystal Nodes</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="connectionCount">0</div>
                        <div class="label">Lattice Links</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="clusterCount">0</div>
                        <div class="label">Facet Clusters</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>‚öôÔ∏è System Controls</h3>
                
                <div class="control-group">
                    <label>Train with Pattern:</label>
                    <textarea id="trainingInput" placeholder="Enter training data (e.g., 'The cat sat on the mat')"></textarea>
                </div>

                <button onclick="trainPattern()">üîÆ Crystallize Pattern</button>
                <button onclick="clearCrystal()">üóëÔ∏è Reset Crystal</button>

                <div class="control-group" style="margin-top: 20px;">
                    <label>Query the Crystal:</label>
                    <input type="text" id="queryInput" placeholder="Ask a question or search pattern">
                </div>

                <button onclick="queryPattern()">üîç Query</button>
                <button onclick="loadDemoData()">üìö Load Demo Knowledge</button>

                <div class="output-box" id="queryOutput">
                    <em style="color: #66ffaa;">Query results will appear here...</em>
                </div>
            </div>
        </div>

        <div class="panel">
            <h3>üßä Crystal Structure Analysis</h3>
            <div class="crystal-info" id="crystalInfo">
                <em style="color: #66ffaa;">Crystal structure details will appear here after training...</em>
            </div>
        </div>
    </div>

    <script>
        // CRYSTALLINE INTELLIGENCE SYSTEM
        // A completely novel AI architecture without neural networks

        class CrystalNode {
            constructor(pattern, type = 'concept') {
                this.pattern = pattern;
                this.type = type;
                this.resonance = 1.0;
                this.connections = new Map();
                this.attributes = {};
                this.activationHistory = [];
                // Position nodes within visible canvas area (800x400 typical size)
                this.x = Math.random() * 700 + 50;
                this.y = Math.random() * 320 + 40;
                this.vx = 0;
                this.vy = 0;
            }

            connectTo(node, strength, relationship) {
                this.connections.set(node, { strength, relationship });
            }

            activate(energy) {
                this.resonance = Math.min(10.0, this.resonance + energy);
                this.activationHistory.push({ time: Date.now(), energy });
            }

            decay() {
                this.resonance *= 0.95;
            }
        }

        class CrystallineIntelligence {
            constructor() {
                this.lattice = new Map();
                this.facets = [];
                this.resonanceThreshold = 0.3;
                this.memoryDepth = 100;
            }

            crystallize(pattern) {
                // Tokenize and create crystal nodes
                const tokens = this.tokenize(pattern);
                const nodes = [];

                tokens.forEach((token, index) => {
                    if (!this.lattice.has(token)) {
                        this.lattice.set(token, new CrystalNode(token));
                    }
                    nodes.push(this.lattice.get(token));
                });

                // Form lattice connections based on proximity and co-occurrence
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const distance = Math.abs(i - j);
                        const strength = 1.0 / (distance + 1);
                        
                        nodes[i].connectTo(nodes[j], strength, 'sequence');
                        nodes[j].connectTo(nodes[i], strength, 'sequence');
                    }
                }

                // Form facets (decision boundaries)
                this.formFacets(nodes);

                return nodes.length;
            }

            tokenize(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s]/g, '')
                    .split(/\s+/)
                    .filter(t => t.length > 0);
            }

            formFacets(nodes) {
                // Create semantic clusters (facets) based on connection patterns
                const facet = {
                    nodes: nodes,
                    centroid: this.calculateCentroid(nodes),
                    strength: nodes.length
                };
                this.facets.push(facet);
            }

            calculateCentroid(nodes) {
                if (nodes.length === 0) return { x: 0, y: 0 };
                const sum = nodes.reduce((acc, node) => ({
                    x: acc.x + node.x,
                    y: acc.y + node.y
                }), { x: 0, y: 0 });
                return {
                    x: sum.x / nodes.length,
                    y: sum.y / nodes.length
                };
            }

            propagateResonance(seedPattern) {
                // Reset resonance
                this.lattice.forEach(node => node.resonance = 0.1);

                const tokens = this.tokenize(seedPattern);
                const activatedNodes = new Set();

                // Initial activation
                tokens.forEach(token => {
                    if (this.lattice.has(token)) {
                        const node = this.lattice.get(token);
                        node.activate(5.0);
                        activatedNodes.add(node);
                    }
                });

                // Propagate through lattice connections
                for (let iteration = 0; iteration < 5; iteration++) {
                    const newActivations = [];
                    
                    activatedNodes.forEach(node => {
                        node.connections.forEach((conn, targetNode) => {
                            const transferEnergy = node.resonance * conn.strength * 0.3;
                            if (transferEnergy > this.resonanceThreshold) {
                                targetNode.activate(transferEnergy);
                                newActivations.push(targetNode);
                            }
                        });
                        node.decay();
                    });

                    newActivations.forEach(n => activatedNodes.add(n));
                }

                // Find most resonant patterns
                const resonantNodes = Array.from(this.lattice.values())
                    .filter(n => n.resonance > 1.0)
                    .sort((a, b) => b.resonance - a.resonance);

                return resonantNodes;
            }

            query(queryPattern) {
                const resonantNodes = this.propagateResonance(queryPattern);
                
                const results = {
                    matches: resonantNodes.slice(0, 10),
                    confidence: resonantNodes.length > 0 ? resonantNodes[0].resonance / 10 : 0,
                    relatedPatterns: this.findRelatedPatterns(resonantNodes.slice(0, 5))
                };

                return results;
            }

            findRelatedPatterns(nodes) {
                const related = new Set();
                nodes.forEach(node => {
                    node.connections.forEach((conn, targetNode) => {
                        if (conn.strength > 0.3) {
                            related.add(targetNode.pattern);
                        }
                    });
                });
                return Array.from(related);
            }

            getStats() {
                const connections = Array.from(this.lattice.values())
                    .reduce((sum, node) => sum + node.connections.size, 0);
                
                return {
                    nodes: this.lattice.size,
                    connections: connections,
                    facets: this.facets.length
                };
            }
        }

        // Initialize system
        const crystal = new CrystallineIntelligence();
        const canvas = document.getElementById('crystalCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size properly
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 400;
            drawBackground();
        }

        function drawBackground() {
            // Clear with visible background
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Add text if no data
            if (crystal.lattice.size === 0) {
                ctx.fillStyle = '#00ff88';
                ctx.font = '16px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('Crystal lattice will appear here after training...', canvas.width / 2, canvas.height / 2);
            }
        }

        resizeCanvas();

        function trainPattern() {
            const input = document.getElementById('trainingInput').value;
            if (!input.trim()) {
                alert('Please enter training data');
                return;
            }

            const nodeCount = crystal.crystallize(input);
            document.getElementById('trainingInput').value = '';
            
            updateStats();
            visualizeCrystal();
            updateCrystalInfo();

            addQueryResult(`‚úì Crystallized ${nodeCount} pattern nodes from input`, '#00ff88');
        }

        function queryPattern() {
            const query = document.getElementById('queryInput').value;
            if (!query.trim()) {
                alert('Please enter a query');
                return;
            }

            const results = crystal.query(query);
            
            let output = `<div class="query-result">`;
            output += `<strong style="color: #00ffff;">Query:</strong> "${query}"<br>`;
            output += `<strong style="color: #00ffff;">Confidence:</strong> ${(results.confidence * 100).toFixed(1)}%<br>`;
            output += `<strong style="color: #00ffff;">Top Matches:</strong> ${results.matches.slice(0, 5).map(m => m.pattern).join(', ') || 'None'}<br>`;
            output += `<strong style="color: #00ffff;">Related:</strong> ${results.relatedPatterns.slice(0, 8).join(', ') || 'None'}`;
            output += `</div>`;

            document.getElementById('queryOutput').innerHTML = output + document.getElementById('queryOutput').innerHTML;
            visualizeCrystal();
        }

        function loadDemoData() {
            const demos = [
                "Artificial intelligence learns patterns from data",
                "Machine learning algorithms process information",
                "Neural networks use backpropagation for training",
                "Crystalline systems grow knowledge structures",
                "Pattern recognition identifies similar features",
                "Data structures organize information efficiently",
                "Algorithms solve computational problems",
                "Intelligence emerges from complex patterns"
            ];

            demos.forEach(demo => {
                crystal.crystallize(demo);
            });

            updateStats();
            visualizeCrystal();
            updateCrystalInfo();
            addQueryResult('‚úì Loaded demo knowledge base', '#00ffff');
        }

        function clearCrystal() {
            crystal.lattice.clear();
            crystal.facets = [];
            updateStats();
            visualizeCrystal();
            document.getElementById('crystalInfo').innerHTML = '<em style="color: #66ffaa;">Crystal cleared. Add new patterns to begin.</em>';
            document.getElementById('queryOutput').innerHTML = '<em style="color: #66ffaa;">Query results will appear here...</em>';
        }

        function updateStats() {
            const stats = crystal.getStats();
            document.getElementById('nodeCount').textContent = stats.nodes;
            document.getElementById('connectionCount').textContent = stats.connections;
            document.getElementById('clusterCount').textContent = stats.facets;
        }

        function visualizeCrystal() {
            // Clear and redraw background
            drawBackground();

            if (crystal.lattice.size === 0) return;

            // Draw connections first (behind nodes)
            ctx.lineWidth = 1;
            crystal.lattice.forEach(node => {
                node.connections.forEach((conn, target) => {
                    if (conn.strength > 0.2) {
                        const alpha = Math.min(0.6, conn.strength);
                        ctx.strokeStyle = `rgba(0, 255, 136, ${alpha})`;
                        ctx.beginPath();
                        ctx.moveTo(node.x, node.y);
                        ctx.lineTo(target.x, target.y);
                        ctx.stroke();
                    }
                });
            });

            // Draw facet boundaries
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            crystal.facets.forEach(facet => {
                if (facet.nodes.length > 2) {
                    ctx.beginPath();
                    facet.nodes.forEach((node, i) => {
                        if (i === 0) ctx.moveTo(node.x, node.y);
                        else ctx.lineTo(node.x, node.y);
                    });
                    ctx.closePath();
                    ctx.stroke();
                }
            });
            ctx.setLineDash([]);

            // Draw nodes on top
            crystal.lattice.forEach(node => {
                const baseSize = 5;
                const size = baseSize + Math.min(10, node.resonance * 1.5);
                const alpha = Math.min(1, 0.3 + node.resonance / 8);
                
                // Outer glow for high resonance
                if (node.resonance > 2) {
                    const glowSize = size + 8;
                    const gradient = ctx.createRadialGradient(node.x, node.y, size, node.x, node.y, glowSize);
                    gradient.addColorStop(0, `rgba(0, 255, 255, ${alpha * 0.5})`);
                    gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Main node
                ctx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fill();

                // Node outline
                ctx.strokeStyle = `rgba(0, 255, 200, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label for high-resonance nodes
                if (node.resonance > 3 && node.pattern.length < 15) {
                    ctx.fillStyle = '#00ffff';
                    ctx.font = 'bold 11px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(node.pattern, node.x, node.y - size - 5);
                }
            });
        }

        function updateCrystalInfo() {
            let html = '';
            const topNodes = Array.from(crystal.lattice.values())
                .sort((a, b) => b.connections.size - a.connections.size)
                .slice(0, 15);

            topNodes.forEach(node => {
                html += `<div class="crystal-node">`;
                html += `<strong>${node.pattern}</strong><br>`;
                html += `Resonance: ${node.resonance.toFixed(2)} | `;
                html += `Connections: ${node.connections.size} | `;
                html += `Type: ${node.type}`;
                html += `</div>`;
            });

            document.getElementById('crystalInfo').innerHTML = html || '<em style="color: #66ffaa;">No patterns crystallized yet.</em>';
        }

        function addQueryResult(message, color) {
            const output = document.getElementById('queryOutput');
            const result = `<div style="color: ${color}; margin-bottom: 8px;">${message}</div>`;
            output.innerHTML = result + output.innerHTML;
        }

        // Animation loop
        function animate() {
            crystal.lattice.forEach(node => {
                node.decay();
                // Gentle movement
                node.x += (Math.random() - 0.5) * 0.5;
                node.y += (Math.random() - 0.5) * 0.5;
                node.x = Math.max(20, Math.min(canvas.width - 20, node.x));
                node.y = Math.max(20, Math.min(canvas.height - 20, node.y));
            });
            
            if (crystal.lattice.size > 0) {
                visualizeCrystal();
            }
            
            requestAnimationFrame(animate);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            visualizeCrystal();
        });
    </script>
</body>
</html>
